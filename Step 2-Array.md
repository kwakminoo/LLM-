## 주요 학습 내용

### C프로그램 구조 복습
- 모든 C 프로그램은 **main()** 함수에서 시작함.
- 함수는 실행 흐름을 나누기 위해 사용하며, **void**, **int** 등의 반환형이 존재함.
- 함수 위에 **프로토타입**을 선언하면 코드 순서와 상관없이 함수 호출 가능

~~~C
#include <stdio.h>

void greet(void) // 함수 프로토타입 선언

int main(void)
{
  greet();
  return 0;
}

void greet(void)
{
  printf("Hello\n");
}
~~~

### 헤더 파일과 컴파일
- **#incude <stdio.h>:** 표준 입출력 함수 포함
- **#include <cs50.h>:** get_string, get_int 등 CS50 전용 함수 사용 가능
- 컴파일링 과정
    1. 전처리(Preprocessing): #include, #define 등 전처리 지시문 처리
    2. 컴파일(Compiling): C 소스코드를 어셈블리어로 변환
    3. 어셈블(Assembling): 어셈블리어를 기계로 변환
    4. 링킹(Linking): 여러 파일/라이브러리를 연결하여 실행파일 생성

### 디버깅과 Breakpoint
- **Breakpoint:** 코드 실행을 특정 지점에서 멈춰 내부 상태(변수 값 등)를 확인할 수 있음
- VScode, Unity 대부분의 IDE에서 사용 가능
- 코드를 단계별로 따라가며 오류를 추적하고 수정하는 데 유용함

### 메모리와 RAM
- RAM은 0과 1을 저장하는 작은 셀들의 배열(격자 구조)
- 각 셀에는 고유한 주소(번지수)가 있음
- 변수나 배열은 이 RAM 공간에 저장되고, 그 위치를 바탕으로 처리됨

### 배열 VS 리스트
| 구분   | 배열 (Array)     | 리스트 (List)      |
| ---- | -------------- | --------------- |
| 구조   | 고정 크기, 연속된 메모리 | 동적 크기, 포인터 연결   |
| 장점   | 빠른 접근          | 삽입/삭제 유연함       |
| 단점   | 크기 변경 어려움      | 느린 접근 속도        |
| 사용 예 | 데이터 개수 확정됨     | 유동적인 데이터 관리 필요시 |

### C에서 배열을 함수에 전달할 때 주의점
- 배열을 함수에 넘기면 **배열 자체가 아니라 시작 주소(포인터)** 만 전달됨
- 이 때문에 배열의 크기를 함수 내부에서 알 수 없음
- 해결: 배열의 길이를 함수 인자로 함께 전달해야 함
~~~C
void print_array(int arr[], int size)
{
  for (int i = 0; i < size; i++)
  {
    printf("%i\n", arr[i]);  
  }
}

// 만약 size를 전달하지 않으면, 어디까지 읽어야 하는지 몰라서
   메모리 오버플로우가 일어나고 프로그램이 오류를 일으킬 수 있음
~~~


### 서식 지정자
| 서식         | 타입     | 설명                 |
| ---------- | ------ | ------------------ |
| `%s`       | string | 문자열                |
| `%c`       | char   | 문자 1개              |
| `%i`, `%d` | int    | 정수                 |
| `%f`       | float  | 실수                 |
| `%.2f`     | float  | 소수점 2자리로 제한된 실수 출력 |


### 보안이 필요한 개념
- 포인터 개념 및 배열과의 관계
- 어셈블리 코드에 대한 이해 (하드웨어와의 연결)
- 함수 분할과 헤더파일 활용한 모듈화
- 메모리 주소와 데이터 저장 방식

## 문제풀기

### 1단계: 개념 확인
| 번호 | 네 답변                                   | 정답                    | 피드백                                           |
| -- | -------------------------------------- | --------------------- | --------------------------------------------- |
| 1  | B                                      | ✅ B                   | 정답! `int`는 반환 타입                              |
| 2  | `<stdio.h>`                            | ❌ `#include <cs50.h>` | `string`은 C 표준 타입이 아니라 **CS50 라이브러리 전용 타입**이야 |
| 3  | C                                      | ✅ C                   | `%f`는 실수용 포맷                                  |
| 4  | "크기를 모르면 멈추는 곳을 몰라 메모리 오버플로가 일어날 수 있음" | ✅ 맞음                  | 간결하면서도 정확하게 잘 썼어!                             |

### 2단계: 코딩 문제
~~~C
#include <stdio.H> <- h
#include <cs50.h>

int main(void)
{
 string name = get_string("What your name?\n ");
 printf("Hello, %s\n", name);
}

//✅ 완벽! 단, #include <stdio.H>는 오타 — 소문자 .h가 맞아.
~~~

~~~C
#include <stdio.H>
#include <cs50.h>

int main(void)
{
 int x = get_int("x의 값: ");
 int y = get_int("y의 값: ); <- "누락
 int value = x + y;
 int Hvalue = (x + y) / 2 <- float Hvalue = (float)(x + y) / 2 

 printf("합: %i, 평균: %2f", value, Hvalue) <- ; 누락
}
~~~

~~~C
int arr[5] = get_int("숫자를 입력하세요: ");

// 배열은 각 칸을 직접 입력받아야 함.

int main(void)
{
  int arr[5]

  for(int i = 0; i < 5; i++)
  {
    arr[i] = get_int("숫자를 입력하세요: ");
  }
  for (int i = 0; i < 5; i++)
  {
    printf("%i\n", arr[i);
  }
}
~~~

### 3단계: 개념 이해
#### 8번
- 배열은 3까지 있지만 i는 5보다 작을 때까지 반복하기 때문에
- 추가 설명: C 언어는 배열 범위를 자동으로 검사하지 않아서,
  nums[3], nums[4]에 접근하면 **쓰레기 값(=예측 불가능한 값)**을 읽거나 심하면 Segmentation Fault가 발생할 수 있음.

#### 9번
- 배열은 전체를 가져오는 것이 아닌 입구인 포인트를 연결하는 방식임으로 sizeof를 알 수 없음
- 추가 설명: 배열을 함수로 넘기면 **배열 전체가 아니라 주소(포인터)** 만 전달됨
  따라서 sizeof(arr)는 배열의 전체 크기가 아니라 **포인터 크기(보통 8바이트)** 가 나옴

#### 10번
- 반환값은 없고 void를 사용하는 이유는 입력도 반환도 없이 printf라는 단순한 기능만 하기 때문

### 챌린지 문제
- 사용자에게 몇 개의 정수를 입력할지를 먼저 물어본 다음, 그 개수만큼 정수를 입력받고 평균을 출력하라.
~~~C

#include <stdio.h>
#include <cs50.h>

int main(void)
{
    // 사용자에게 입력 개수 묻기
    int n = get_int("몇 개의 정수를 입력하시겠습니까?");
    // 배열 선언
    int arr[a]; // C99 이상에서는 허용됨
    
    // 배열의 사용자 입력 저장
    for(int i = 0; i < n; i++)
    {
        arr[i] = get_int("정수를 입력하세요: ");
    }
    
    // 총합 계산
    int sum = 0;
    
    for(int i = 0; i < n; i++)
    {
        sum += arr[i];
    }
    
    // 평균 계산
    float average = (float)sum / n;
    
    // 결과 출력
    printf("합계: %i\n", sum);
    printf("평균: %.2f\n", average);
    
    return 0;
}
~~~

#### 보충 설명
| 개념               | 설명                            |
| ---------------- | ----------------------------- |
| `int arr[n];`    | C99 이상에서 가능한 "가변 길이 배열 (VLA)" |
| `sum += arr[i];` | 배열 값 하나씩 더해서 총합 구하기           |
| `(float)sum / n` | 정수 나눗셈을 실수 나눗셈으로 변환,            |
- 변수를 float average;로 선언했는데도 (float)sum / n처럼 **명시적으로 형변환(casting)**을 하는 이유는,
연산이 일어나는 시점의 데이터 타입 때문이야.

### 함수와 반환값
- 'int main(void): 프로그램 시작 지점, 'int'는 **변환 타입**
- 'void greet(void): **입력도 없고 반환도 없는** 함수
- 'return 값;' -> 함수가 결과를 **돌려줌**
    - 'void' 함수는 'return;' 생략 가능
 
### 함수 프로토타입과 전처리기
- 함수가 아래에 정의되어 있으면 **위에 선언(프로토타입)** 필요
    -ex: void greet(void);
    - 전처리기(#include, #define)가 코드 실행 전에 처리
 
### 문자열 저장 구조
- "HI!"는 메모리상에서 'H', 'I', '!', '\0'으로 저장됨
- 문자열은 널 문자(\0)로 끝나는 문자 배열
- 그래서 string("HI!") == 3 이지만 실제 메모리 사용은 4바이트

### 배열과 리스트, 포인터 차이
- 배열은 고정 크기
    ~~~C
    int arr[3] = {1, 2, 3};
    ~~~
- 배열은 전체를 넘기는 게 아니라 첫 번째 요소의 주요(포인터) 전달
- 그래서 sizeof(arr)와 sizeof(arr[0])을 사용해 크기 계산
- 리스트는 동적 자료구조 (C 기본 문법에선 별도 구현)

### mina(int argc, char argv[])
- 명령줄 인자 사용
    ~~~C
    ./hello Alice
    → argc == 2
    → argv[0] == "./hello"
    → argv[1] == "Alice"
    ~~~

### 어셈블리 개념 간략 소개
- 컴파일 과정: 소스코드 -> 어셈블리 -> 기계어
- 어셈블리는 사람이 읽을 수 있는 저수준 언어
- 파일, 함수, 변수는 전부 메모리 블록에 저장됨


## 📘 CS50 Week 2 복습 퀴즈 및 해설

### ✅ 1단계: 개념 문제

#### **문제 1**

다음 중 C에서 main 함수의 표준 선언 방식은?

A. `void main()`
B. `int main(void)`
C. `main() void`

* **너의 답:** B, C
* **정답:** ✅ B
* **해설:** C 표준에 따르면 `main` 함수는 반드시 `int` 타입을 반환해야 해. 즉, `int main(void)`가 정식 선언이야.

---

#### **문제 2**

배열을 함수에 전달할 경우 어떤 특징이 있는가?

A. 배열의 크기도 함께 전달된다.
B. 배열의 모든 요소가 복사된다.
C. 배열의 시작 주소만 전달된다.

* **너의 답:** C
* **정답:** ✅ C
* **해설:** 배열을 함수에 넘기면 배열 전체가 아니라 **시작 주소(포인터)** 만 전달되므로 함수 내부에서는 배열 크기를 알 수 없어.

---

#### **문제 3**

다음 중 전처리 단계에 해당하는 작업은?

A. C 코드를 어셈블리어로 변환
B. 어셈블리어를 기계어로 변환
C. `#include`, `#define` 처리

* **너의 답:** A
* **정답:** ✅ C
* **해설:** 전처리는 컴파일 전에 `#include`, `#define` 등 **지시문을 처리하는 단계**야. 어셈블리어로 변환은 컴파일 단계야.

---

#### **문제 4**

실수를 출력할 때 사용하는 서식 지정자는?

A. `%i`
B. `%c`
C. `%f`

* **너의 답:** C
* **정답:** ✅ C
* **해설:** `%f`는 float형 실수를 출력할 때 사용해.

---

### ✅ 2단계: 코드 문제

#### **문제 5** `get_int()`로 배열 입력 받기

```c
int arr[5] = get_int("숫자를 입력하세요:"); // ❌ 오류 발생
```

* **해설:** `get_int()`는 **정수 하나만** 받을 수 있어. 배열에는 반복문으로 하나씩 값을 넣어야 해.

```c
int arr[5];
for (int i = 0; i < 5; i++) {
    arr[i] = get_int("숫자를 입력하세요: ");
}
```

---

#### **문제 6** 출력 결과

* **문제:**

```c
printf("Hello, World!\n");
```

* **너의 답:** Hello, World! → ✅ 정답

---

#### **문제 7** Breakpoint에 대한 설명

A. 오류를 제거하는 도구
B. 메모리를 초기화하는 기능
C. 디버깅 중 특정 지점에서 멈추는 기능

* **너의 답:** C
* **정답:** ✅ C
* **해설:** Breakpoint는 디버깅 도중 코드 실행을 **일시 중단**하고 변수 상태 등을 확인하는 데 사용돼.

---

### ✅ 3단계: 서술형 문제

#### **문제 8**

배열을 함수에 전달할 때, 배열의 크기를 함수 내부에서 알 수 없는 이유는?

* **너의 답:** 배열은 포인터만 연결하고 전체를 가져오는 게 아니기 때문
* **정답:** ✅ 정답

---

#### **문제 9**

`#include <cs50.h>`는 무슨 역할을 하나요?

* **너의 답:** 그 안에 있는 함수들을 가져와서 쓸 수 있게 함
* **정답:** ◑ 반은 맞고, 설명 보완 필요
* **해설:** `#include`는 해당 헤더파일의 내용을 **현재 파일로 복사해 붙이는 전처리 지시문**이야. 그래서 CS50의 `get_int`, `get_string` 등을 쓸 수 있게 돼.

---

#### **문제 10**

문자열 "HI!"는 메모리상에 몇 개의 문자로 저장되는가?

* **너의 답:** string은 HI!가 하나의 칸으로 저장됨 → ❌
* **정답:** 4칸 (`'H'`, `'I'`, `'!'`, `\0`)
* **해설:** 문자열은 \*\*마지막에 null 문자 `\0`\*\*이 자동 추가되므로 메모리에는 4칸이 필요해.

