## 주요 학습 내용

### C프로그램 구조 복습
- 모든 C 프로그램은 **main()** 함수에서 시작함.
- 함수는 실행 흐름을 나누기 위해 사용하며, **void**, **int** 등의 반환형이 존재함.
- 함수 위에 **프로토타입**을 선언하면 코드 순서와 상관없이 함수 호출 가능

~~~C
#include <stdio.h>

void greet(void) // 함수 프로토타입 선언

int main(void)
{
  greet();
  return 0;
}

void greet(void)
{
  printf("Hello\n");
}
~~~

### 헤더 파일과 컴파일
- **#incude <stdio.h>:** 표준 입출력 함수 포함
- **#include <cs50.h>:** get_string, get_int 등 CS50 전용 함수 사용 가능
- 컴파일링 과정
    1. 전처리(Preprocessing): #include, #define 등 전처리 지시문 처리
    2. 컴파일(Compiling): C 소스코드를 어셈블리어로 변환
    3. 어셈블(Assembling): 어셈블리어를 기계로 변환
    4. 링킹(Linking): 여러 파일/라이브러리를 연결하여 실행파일 생성

### 디버깅과 Breakpoint
- **Breakpoint:** 코드 실행을 특정 지점에서 멈춰 내부 상태(변수 값 등)를 확인할 수 있음
- VScode, Unity 대부분의 IDE에서 사용 가능
- 코드를 단계별로 따라가며 오류를 추적하고 수정하는 데 유용함

### 메모리와 RAM
- RAM은 0과 1을 저장하는 작은 셀들의 배열(격자 구조)
- 각 셀에는 고유한 주소(번지수)가 있음
- 변수나 배열은 이 RAM 공간에 저장되고, 그 위치를 바탕으로 처리됨

### 배열 VS 리스트
| 구분   | 배열 (Array)     | 리스트 (List)      |
| ---- | -------------- | --------------- |
| 구조   | 고정 크기, 연속된 메모리 | 동적 크기, 포인터 연결   |
| 장점   | 빠른 접근          | 삽입/삭제 유연함       |
| 단점   | 크기 변경 어려움      | 느린 접근 속도        |
| 사용 예 | 데이터 개수 확정됨     | 유동적인 데이터 관리 필요시 |

### C에서 배열을 함수에 전달할 때 주의점
- 배열을 함수에 넘기면 **배열 자체가 아니라 시작 주소(포인터)** 만 전달됨
- 이 때문에 배열의 크기를 함수 내부에서 알 수 없음
- 해결: 배열의 길이를 함수 인자로 함께 전달해야 함
~~~C
void print_array(int arr[], int size)
{
  for (int i = 0; i < size; i++)
  {
    printf("%i\n", arr[i]);  
  }
}

// 만약 size를 전달하지 않으면, 어디까지 읽어야 하는지 몰라서
   메모리 오버플로우가 일어나고 프로그램이 오류를 일으킬 수 있음
~~~


### 서식 지정자
| 서식         | 타입     | 설명                 |
| ---------- | ------ | ------------------ |
| `%s`       | string | 문자열                |
| `%c`       | char   | 문자 1개              |
| `%i`, `%d` | int    | 정수                 |
| `%f`       | float  | 실수                 |
| `%.2f`     | float  | 소수점 2자리로 제한된 실수 출력 |


### 보안이 필요한 개념
- 포인터 개념 및 배열과의 관계
- 어셈블리 코드에 대한 이해 (하드웨어와의 연결)
- 함수 분할과 헤더파일 활용한 모듈화
- 메모리 주소와 데이터 저장 방식

## 문제풀기

### 1단계: 개념 확인
| 번호 | 네 답변                                   | 정답                    | 피드백                                           |
| -- | -------------------------------------- | --------------------- | --------------------------------------------- |
| 1  | B                                      | ✅ B                   | 정답! `int`는 반환 타입                              |
| 2  | `<stdio.h>`                            | ❌ `#include <cs50.h>` | `string`은 C 표준 타입이 아니라 **CS50 라이브러리 전용 타입**이야 |
| 3  | C                                      | ✅ C                   | `%f`는 실수용 포맷                                  |
| 4  | "크기를 모르면 멈추는 곳을 몰라 메모리 오버플로가 일어날 수 있음" | ✅ 맞음                  | 간결하면서도 정확하게 잘 썼어!                             |

### 2단계: 코딩 문제
~~~C
#include <stdio.H> <- h
#include <cs50.h>

int main(void)
{
 string name = get_string("What your name?\n ");
 printf("Hello, %s\n", name);
}

//✅ 완벽! 단, #include <stdio.H>는 오타 — 소문자 .h가 맞아.
~~~

~~~C
#include <stdio.H>
#include <cs50.h>

int main(void)
{
 int x = get_int("x의 값: ");
 int y = get_int("y의 값: ); <- "누락
 int value = x + y;
 int Hvalue = (x + y) / 2 <- float Hvalue = (float)(x + y) / 2 

 printf("합: %i, 평균: %2f", value, Hvalue) <- ; 누락
}
~~~

~~~C
int arr[5] = get_int("숫자를 입력하세요: ");

// 배열은 각 칸을 직접 입력받아야 함.

int main(void)
{
  int arr[5]

  for(int i = 0; i < 5; i++)
  {
    arr[i] = get_int("숫자를 입력하세요: ");
  }
  for (int i = 0; i < 5; i++)
  {
    printf("%i\n", arr[i);
  }
}
~~~

### 3단계: 개념 이해
#### 8번
- 배열은 3까지 있지만 i는 5보다 작을 때까지 반복하기 때문에
- 추가 설명: C 언어는 배열 범위를 자동으로 검사하지 않아서,
  nums[3], nums[4]에 접근하면 **쓰레기 값(=예측 불가능한 값)**을 읽거나 심하면 Segmentation Fault가 발생할 수 있음.

#### 9번
- 배열은 전체를 가져오는 것이 아닌 입구인 포인트를 연결하는 방식임으로 sizeof를 알 수 없음
- 추가 설명: 배열을 함수로 넘기면 **배열 전체가 아니라 주소(포인터)** 만 전달됨
  따라서 sizeof(arr)는 배열의 전체 크기가 아니라 **포인터 크기(보통 8바이트)** 가 나옴

#### 10번
- 반환값은 없고 void를 사용하는 이유는 입력도 반환도 없이 printf라는 단순한 기능만 하기 때문
